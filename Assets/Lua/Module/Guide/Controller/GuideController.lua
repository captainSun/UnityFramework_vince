---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by sunshuo.
--- DateTime: 2020/12/18 17:34
--- 引导控制器
--- 每段引导为单独的lua文件 创建在Guide.Definition下 以"Guide_"为前缀
---
local GuideBlackBg = require("Module.Guide.View.GuideBlackBg")
local GuideSkipBtnView = require("Module.Guide.View.GuideSkipBtnView")
---@class  Guide.GuideController
local GuideController = {}

---指令定义映射表
GuideController.actionList = {
    ["arrow"] = require("Module.Guide.Action.GuideArrow"),
    ["wait"] = require("Module.Guide.Action.GuideWait"),
    ["callback"] = require("Module.Guide.Action.GuideCallBack"),
    ["delay"] = require("Module.Guide.Action.GuideDelay"),
    ["performance"] = require("Module.Guide.Action.GuidePerformance"),
    ["jump"] = require("Module.Guide.Action.GuideJump"),
}

---------------------------------------------------------------------------------------------
---启动引导
---@param key string 引导的名字
---@param pathOrGuide string|table 引导文件的路径或实例
---@param isClean boolean 是否清除package缓存 仅对传文件路径有效(清除后 在执行require将重新加载此文件)
local function BeginGuide(key, pathOrGuide, isClean)
    if GuideData.waitGuideEndList then
        if GuideData.waitGuideEndList.isStart then
            --暂时持有引导
            log("GuideWaitEnd：拦截成功   key=="..key)

            GuideData.waitGuideEndList.guideData = {key=key,pathOrGuide=pathOrGuide,isClean=isClean}
            return
        end
    end
    if GuideData.curGuideInfo ~= nil then
        GuideData.DebugWarningLog(GuideData.GUIDE_DOING_ERROR, key)
        return
    end
    local guide = pathOrGuide
    if type(pathOrGuide) == "string" then
        if isClean then
            package.loaded[pathOrGuide] = nil
        end
        guide = require(pathOrGuide)
    end

    if type(guide) ~= "table" then
        logError("BeginGuide 该文件没有返回值 Guide_"..tostring(key))
        return
    end

    if guide.guideInfo == nil then
        logError("BeginGuide 该文件没有配置引导 Guide_"..tostring(key))
        return
    end

    local sceneName = guide.sceneName or MCData.NAME --判断启动引导时场景的名字
    local cueSceneName = SceneManager.GetCurrentSceneName()
    if not cueSceneName == sceneName then
        logError("BeginGuide 当前引导不在使用场景 Guide_"..tostring(key))
        return
    end
    GuideData.curGuideInfo = guide.guideInfo
    GuideData.curGuideName = key
    GuideData.curGuideIndex = 0
    if guide.isShowBg then
        GuideData.GuideBlackBg = GuideBlackBg.New()
    end
    if GuideData.GuideSkipBtn == nil then
        GuideData.GuideSkipBtn = GuideSkipBtnView.New()
    end
    GuideController.NextAction()
end

---执行引导
---@param key string 引导段落名字
---@param isClean boolean 与BeginGuide参数相同
function GuideController.ExecuteGuide(key, isClean)
    if key == nil or key == "" then
        GuideData.DebugWarningLog(GuideData.NO_KEY_ERROR)
        return
    end
    local guidePath = string.format("Module.Guide.Definition.Guide_%s", tostring(key))
    if not Res.LuaFileExists(guidePath) then
        GuideData.DebugWarningLog(GuideData.NO_GUIDE_ERROR)
        return
    end
    if AutoMergeCfg.inAutoMerge then
        --在自动合成中则引导延迟调用
        logWarning(string.format(GuideData.IN_AUTO_MERGE_NOTICE, key))
        GuideController.tempKey = key
        GuideController.tempIsClean = isClean
        AddEventListener(AutoMergeCfg, AutoMergeCfg.autoMergeEnd, GuideController.MergeDelay, GuideController)
    else
        BeginGuide(key, guidePath, isClean)
    end
end

function GuideController.MergeDelay()
    print("因自动合成而延迟的引导【%s】 执行", GuideController.tempKey)
    RemoveEventListener(AutoMergeCfg, AutoMergeCfg.autoMergeEnd, GuideController.MergeDelay, GuideController)
    local guidePath = string.format("Module.Guide.Definition.Guide_%s", tostring(GuideController.tempKey))
    BeginGuide(GuideController.tempKey, guidePath, GuideController.tempIsClean)
    GuideController.tempKey = nil
end

---执行下一个引导命令
function GuideController.NextAction()
    if GuideData.curGuideIndex == nil then
        error("GuideController curGuideIndex 为nil")
        return
    end
    GuideData.curGuideAction = nil
    GuideData.curGuideIndex = GuideData.curGuideIndex + 1
    local guideInfo = GuideData.curGuideInfo[GuideData.curGuideIndex]
    if guideInfo == nil then
        --print("NextAction 引导结束", debug.traceback())
        ---已经到最后 引导结束
        GuideData.executeGuideCfg[GuideData.curGuideName] = true --记录执行过的引导
        GuideController.SetGuideRecord(GuideData.curGuideName)
        GuideController.EndGuide()
    else
        --print("NextAction GuideData.curGuideIndex", GuideData.curGuideIndex, debug.traceback())
        ---继续执行下个引导命令
        local command = guideInfo.command
        if command == nil then
            GuideData.DebugWarningLog(GuideData.NO_COMMAND_ERROR)
            return
        end
        local actionClass = GuideController.actionList[command]
        if actionClass == nil then
            GuideData.DebugWarningLog(GuideData.NO_ACTION_ERROR, command)
            return
        end

        local action = actionClass.New() ---@type Guide.Action.BaseGuideAction
        GuideData.curGuideAction = action
        --判断的是否显示跳过引导按钮

        if actionClass.SkipCallback ~= actionClass.super.SkipCallback then
            --print("当前command curGuideIndex Show", command, GuideData.curGuideIndex, debug.traceback())
            GuideData.GuideSkipBtn:Show()
        else
            --print("当前command curGuideIndex Hide", command, GuideData.curGuideIndex, debug.traceback())
            GuideData.GuideSkipBtn:Hide()
        end

        if not trycall(action.Execute, action) then
            GuideData.DebugWarningLog(GuideData.ACTION_EXECUTE_ERROR, command)
            return
        end

    end
end

---结束引导
function GuideController.EndGuide()
    GuideData.curGuideInfo = nil
    GuideData.curGuideName = nil
    GuideData.curGuideIndex = nil
    if GuideData.GuideBlackBg then
        GuideData.GuideBlackBg:Destroy()
        GuideData.GuideBlackBg = nil
    end
    GuideData.GuideSkipBtn:Hide()
end

-------------------------------------------------------------------

---打开引导状态下模态
function GuideController.GuideShowModal(canClick)
    if MCData.scene and MCData.scene.mergeArea then
        MCData.scene.mergeArea:RemoveListener()
        MCData.scene.mergeArea:Reset()
    end
    if canClick == nil or canClick == false then
        Stage.ShowModal()
    end
    CameraMovement.SetComponent(false)
end

---关闭引导状态下模态
---@param canMerge boolean 是否恢复合成 默认恢复
function GuideController.GuideHideModal(canMerge)
    if MCData.scene and MCData.scene.mergeArea and (canMerge == nil or canMerge == true) then
        MCData.scene.mergeArea:AddListener()
    end
    Stage.HideModal()
    CameraMovement.SetComponent(true)
end

---设置引导对象
---@param go UnityEngine.GameObject 引导对象的gameObject(带有点击的对象)
---@vararg any 用来映射引导对象的key 可以多个key对应一个对象
function GuideController.SetTarget(go, ...)
    if isnull(go) then
        logError("GuideController SetTarget 引导对象不存在")
        return
    end
    local args = { ... }
    if #args == 0 then
        logError("GuideController SetTarget 没有设置引导对象的名字")
        return
    end
    for i = 1, #args do
        local name = args[i]
        GuideData.targetList[name] = go
        ---派发引导对象设置完成事件
        local event = Event.Get(GuideEvent,GuideEvent.INIT_TARGET_EVENT, name)
        DispatchEvent(GuideData, event)
    end
end

---清理引导对象
---@param name string 引导对象的名字
function GuideController.CleanTarget(name)
    GuideData.targetList[name] = nil
end

---获取引导对象
---@param name string 引导对象的名字
---@return UnityEngine.GameObject 对象物体
function GuideController.GetTarget(name)
    if GuideData.targetList[name] == nil then
        logWarning(string.format("GuideController 没有找到该引导对象: %s", name))
        return
    end
    return GuideData.targetList[name]
end


-----------------------------------任务引导相关------------------------------------
--- 【任务引导创建规范】
--- 每个引导单独创建文件 文件创建在Guide.Definition下
---
--- [自动推送任务引导]: 命名规则 Guide_taskKey taskKey:任务表中配置的key

---执行自动推送任务的引导
---@field taskKey string 任务表中配置的key
function GuideController.Execute_AutoTaskGuide(taskKey)
    if taskKey == nil or taskKey == "" then
        GuideData.DebugErrorLog(GuideData.NO_KEY_ERROR)
        return
    end
    local url = string.format("Module.Guide.Definition.Guide_%s", taskKey)
    if not Res.LuaFileExists(url) then
        print("自动推送任务引导 任务没有配置该引导 taskKey:", taskKey)
        return
    end
    BeginGuide(taskKey, url)
end

---记录最近的引导taskKey
function GuideController.SetGuideRecord(taskKey)
    PlayerPrefsKey.SetStringByKey(PlayerPrefsKey.curGuideTaskKey, taskKey)
    print("SetGuideRecord taskKey ", taskKey)
end

---判断该taskKey对应引导是否执行过
function GuideController.CheckGuideRecord(taskKey)
    if taskKey == nil or taskKey == "" then
        GuideData.DebugErrorLog(GuideData.NO_KEY_ERROR)
        return
    end
    local key = PlayerPrefsKey.GetStringByKey(PlayerPrefsKey.curGuideTaskKey, "")
    if key == taskKey then
        local guide = require(string.format("Module.Guide.Definition.Guide_%s", taskKey))
        if guide.repeatFlag then
            ---如果配置了可重复字段 可以重复执行
            return false
        else
            return true
        end
    end
    return false
end

---跳过当前引导命令
function GuideController.SkipGuideAction(needNext)
    if GuideData.curGuideAction == nil then
        GuideData.DebugWarningLog(GuideData.NO_GUIDE_ACTION)
        return
    end
    local action = GuideData.curGuideAction
    if action.SkipCallback ~= action.super.SkipCallback then
        action:SkipCallback()
        if needNext == nil or needNext == true then
            GuideController.NextAction()
        end
    else
        logWarning("SkipGuideAction 当前引导命令不可跳过"..tostring(action.actionVo.command))
    end
end

---跳过当前引导
function GuideController.SkipGuide()
    ---先跳过当前在执行的引导命令
    GuideController.SkipGuideAction(false)

    local curIndex = GuideData.curGuideIndex
    local guideInfo = GuideData.curGuideInfo
    local targetIndex --目标下标
    if guideInfo[curIndex + 1] ~= nil then
        ---若guideInfo为空 则说明引导已经执行到最后 无需检查下文
        ---若guideInfo不为空 则遍历引导下文 跳转到不能跳过的引导命令所在下标
        for i = curIndex + 1, #guideInfo do
            local info = guideInfo[i]
            local command = GuideController.actionList[info.command]
            if command.SkipCallback ~= command.super.SkipCallback then
                --可以跳过
                targetIndex = i
            else
                --不可以跳过
                break
            end
        end
    end

    if targetIndex then
        ---若找到了目标下标则赋值给curGuideIndex
        ---若没有则保持原值
        GuideData.curGuideIndex = targetIndex
    end
    --print("GuideData.curGuideIndex === ", GuideData.curGuideIndex)
    ---继续引导
    GuideController.NextAction()
end

---jump命令使用 跳转到指定引导
function GuideController.JumpGuide(jumpKey)
    local curIndex = GuideData.curGuideIndex
    local guideInfo = GuideData.curGuideInfo
    local targetIndex --目标下标
    for i = curIndex, #guideInfo do
        local info = guideInfo[i]
        if info.jumpKey ~= nil and info.jumpKey == jumpKey then
            targetIndex = i
            break
        end
    end
    if targetIndex == nil then
        GuideData.DebugWarningLog(GuideData.JUMP_KEY_ERROR, jumpKey)
    else
        GuideData.curGuideIndex = targetIndex - 1
    end
    GuideController.NextAction()
end

return GuideController